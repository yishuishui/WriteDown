
定时器Timer类是一个最基础的定时调度任务的类。
这个类的参数有以下几个：
         //定时器任务队列，上面的定时器线程就是从这个队列中取任务来执行。有新任务需要加入也是放到这个队列中
         private final TaskQueue queue = new TaskQueue();
				 //定时器线程，负责调度定时器任务
         private final TimerThread thread = new TimerThread(queue);
---------------------------------------------------------------------------------------------------------------        
默认的构造函数有以下几个：
（1）
    public Timer() {
        this("Timer-" + serialNumber());
    }
    这个构造函数调用了另一个构造函数，从而给线程设置一个默认的名字。这个名字就是Timer-加上一个serialNumber();
    我们来看看这个serialNumber()是什么鬼？
    private final static AtomicInteger nextSerialNumber = new AtomicInteger(0);
    private static int serialNumber() {
        return nextSerialNumber.getAndIncrement();
    }
    原来这个serialNumber就是一个自增的数据，这个调用了AtomicInteger类来实现技术的。
    这个设置为静态，说明我们在用户代码中假如创建多个定时器，也能保证每个定时器能得到一个独一无二的、递增的序列号。
（2）这个构造函数可以用户自定义线程名称
      public Timer(String name) {
        thread.setName(name);
        thread.start();
    }
 （3）这个构造函数使用默认的名字和设置守护线程
     public Timer(boolean isDaemon) {
        this("Timer-" + serialNumber(), isDaemon);
    }
 （4）这个构造函数可以设置名字和设置守护线程
        public Timer(String name, boolean isDaemon) {
        thread.setName(name);
        thread.setDaemon(isDaemon);
        thread.start();
    }
-------------------------------------------------------------------------------------------------------------------
 接下来我们看看这个TimerTask类，看看这个类有啥特殊的？
 这个TimerThread是一个抽象的类，这个类继承了Thread类。其中抽象方法为：
         public abstract void run();
  我们看看这个类中还有其他什么？通过下面几个变量标识线程的不同工作状态，默认值为0.
     int state = VIRGIN;
     static final int VIRGIN = 0;
     static final int SCHEDULED   = 1;
     static final int EXECUTED    = 2;
     static final int CANCELLED   = 3;
  这个类中还有两个和调度相关的变量：  long nextExecutionTime;//下一次任务执行时间
                                   long period = 0; //任务调度周期，也就是每多长时间调度一次
  我们看看这个类中还有个取消的方法，这个方法只是将线程状态标识为cannel状态。
       public boolean cancel() {
        synchronized(lock) {
            boolean result = (state == SCHEDULED);
            state = CANCELLED;
            return result;
        }
    }
    
下面是定时器调度算法的核心：
    private void sched(TimerTask task, long time, long period) {
        if (time < 0)
            throw new IllegalArgumentException("Illegal execution time.");

        //首先检查一下参数
        if (Math.abs(period) > (Long.MAX_VALUE >> 1))
            period >>= 1;

        synchronized(queue) {
            if (!thread.newTasksMayBeScheduled)
                throw new IllegalStateException("Timer already cancelled.");
            //每个任务有一把锁，这个锁其实就是一个Object对象
            synchronized(task.lock) {
                if (task.state != TimerTask.VIRGIN) //查看一下工作线程TimerThread的状态是否合法
                    throw new IllegalStateException(
                        "Task already scheduled or cancelled");
                task.nextExecutionTime = time;
                task.period = period;
                task.state = TimerTask.SCHEDULED;
            }
            //加入任务到队列中
            queue.add(task);
            if (queue.getMin() == task) //该取任务了，如果取到当前任务，说明需要执行，立马唤醒！！！
                queue.notify();
        }
    }
总结
（1）创建Timer定时器，有4个构造函数，默认会设置一个“Timer-自增数字”的名字。其他构造函数可以设置名字、设置守护线程。
（2）每个Timer中包含了一个TimerThread，也就是说一个定时器就是一个线程。
     每个Timer中还包含了一个TaskQueue，从上面我们知道这个Queue就是装着TimerTask的对象。
（3）
